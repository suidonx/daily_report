## 取り組んだ課題一覧
- JavaScript Primer
	- 第1章 基本文法
## わかったこと
- 配列に関しても分割代入を利用できる
```
function print([first, second]) {
    console.log(first); // => 1
    console.log(second); // => 2
}
const array = [1, 2];
print(array);
```

- 関数はオブジェクト
	- ()をつけて呼び出さなければ、関数をオブジェクトとして参照できる
	- `const myFunc = fn;`
	- 関数が値として扱えることをファーストクラスファンクションという

- 関数式
	- 関数を値として変数へ代入している式のこと
```
const 変数名 = function() {
    // 関数を呼び出したときの処理
    // ...
    return 関数の返り値;
};

// 関数式は変数名で参照できるため、"関数名"を省略できる
const 変数名 = function() {
};
// 関数宣言では"関数名"は省略できない
function 関数名() {
}
```

- 無名関数
	- 名前を持たない関数のこと
	- 関数式でも名前をつけることができる
	- 再帰関数で使う時に名前をつける。

- Arrow Function
```
// 仮引数の数と定義
const fnA = () => { /* 仮引数がないとき */ };
const fnB = (x) => { /* 仮引数が1つのみのとき */ };
const fnC = x => { /* 仮引数が1つのみのときは()を省略可能 */ };
const fnD = (x, y) => { /* 仮引数が複数のとき */ };
// 値の返し方
// 次の２つの定義は同じ意味となる
const mulA = x => { return x * x; }; // ブロックの中でreturn
const mulB = x => x * x;            // 1行のみの場合はreturnとブロックを省略できる
```

- Arrow Functionの特徴
	- 常に無名関数
	- functionと比べて短くかける
	- newできない
	- arguments変数を参照できない
	- thisが静的に決定できる
	- 基本的にArrow Functionで書く。そうでない場合はfunctionキーワードを使う

- コールバック関数
	- 引数として渡される関数
	- forEachメソッドはコールバック関数を引数として受け取る高階関数
```
const array = [1, 2, 3];
const output = (value) => {
    console.log(value);
};
array.forEach(output);
// 次のように実行しているのと同じ
// output(1); => 1
// output(2); => 2
// output(3); => 3
```

- メソッド
	- オプジェクトのプロパティである関数をメソッド

- メソッドの短縮記法
```
const obj = {
    method() {
        return "this is method";
    }
};
console.log(obj.method()); // => "this is method"
```

- 式
	- 値を生成し、変数に代入できるもの
	- リテラルや変数、関数呼び出しなど。

- 文
	- 処理する1ステップ

- 式文
	- 式;のこと

- ブロック文
	- {}で終わる文にはセミコロンが不要となる。
	- ブロックを使ってスコープを作れば、REPLを使うとき変数定義が被らなくて嬉しい

- 関数宣言と関数式
```
function fn() {}
// fn(式)の評価値を代入する変数宣言の文
const read = fn;
```

- switch文
```
switch (式) {
    // if (式 === "ラベル1")
    case "ラベル1":
        break;
    // else if (式 === "ラベル2")
    case "ラベル2":
        break;
    // else
    default:
        break;
}
```
- 式の評価結果を`===`で一致するラベルを探して一致したラベルがあればその文を実行
- 関数と組み合わせて使うことが多い

- 配列のforEachメソッド
	- 引数のコールバック関数には、配列の要素が先頭から順番に渡されて実行される
	- 配列の全ての要素を反復処理する

- 配列のsomeメソッド
	- 配列の各要素をテストする処理をコールバック関数として受け取る
	- 配列に偶数が含まれているかテストする処理
```
function isEven(num) {
    return num % 2 === 0;
}
const numbers = [1, 5, 10, 15, 20];
console.log(numbers.some(isEven)); // => true
```

- for ... in文
	- 有用そうに見えるが多くの問題がある
	- オブジェクトは何らかのオブジェクトを継承している
	- for ... in文でプロパティを列挙する場合に親オブジェクトまで探索して列挙する
	- 安全にオブジェクトのプロパティを列挙するには
		- Object.keys
		- Object.values
		- Object.entries
	- 配列を入れた場合はインデックスが文字化した文字列が...に入る
		- 配列に対して反復処理をする場合はfor ... of文
```
const numbers = [5, 10];
let total = 0;
for (const num in numbers) {
    // 0 + "0" + "1" という文字列結合が行われる
    total += num;
}
console.log(total); // => "001"
```

- iterableオブジェクト
	- Symbol.iteratorという名前のメソッドを実装したオブジェクトのこと
```
const array = [1, 2, 3];
for (const value of array) {
    console.log(value);
}
// 1
// 2
// 3
```

- オブジェクト
	- プロパティの集合
	- プロパティはキーとバリューで対応付されているもの
	- 配列や関数もオブジェクトで、あらゆるオブジェクトの元にObjectというビルトインオブジェクトがある
	- `const obj = {};`

- プロパティ名と値に指定する変数名が同じ場合、省略して書ける
```
const name = "namae";
const obj = {
	name
};
console.log(obj); // => {name: "namae";}が出力
```

- 分割代入でオブジェクトからよく使うプロパティを取り出す
```
const languages = {
    ja: "日本語",
    en: "英語"
};
const { ja, en } = languages;
console.log(ja); // => "日本語"
console.log(en); // => "英語"
```
- const ja = languages.jaと解釈される

- キーに変数を使う
```
const key = "key-string";
// Computed Propertyで`key`の評価結果 "key-string" をプロパティ名に利用
const obj = {
    [key]: "value"
};
console.log(obj[key]); // => "value"
```
- keyだと文字列としての"key"
- `[key]`は変数keyを評価した結果

- オブジェクトのプロパティはできる限り作成後に新しいプロパティは追加しない方が良い
	- オブジェクトがどのようなプロパティを持っているかがわかりにくくなる
	- オブジェクトリテラルの中で定義するのが推奨

- プロパティの存在確認
	- プロパティ名を間違えた時、存在しないプロパティにアクセスした時、例外がでない
		- undefinedという値が返ってくるだけ
	- プロパティをネストして間違えてアクセスした時に初めて例外出る
	- in演算子を使ってkey: valueが定義されているか調べる
	- `Object.hasOwn`静的メソッドを使う
		- プロパティ名を確認

- プロパティへアクセスする時、undefinedとの比較が冗長
	- `?.`演算子を使ってプロパティへアクセスする
	- 存在しないプロパティへアクセスした場合でも例外はでない、undefinedを返す
	- A?.B
		- Aがnull、undefinedだったらundefinedを返す
```
const obj = {
    a: {
        b: "objのaプロパティのbプロパティ"
    }
};

// obj.a.b は存在するので、その評価結果を返す
console.log(obj?.a?.b); // => "objのaプロパティのbプロパティ"
// 存在しないプロパティのネストも`undefined`を返す
// ドット記法の場合は例外が発生してしまう
console.log(obj?.notFound?.notFound); // => undefined
// undefinedやnullはnullishなので、`undefined`を返す
console.log(undefined?.notFound?.notFound); // => undefined
console.log(null?.notFound?.notFound); // => undefined
```

- オブジェクトのプロパティへアクセスする際に、指定したプロパティ名は暗黙的に文字列に変換される
	- オブジェクトであるkeyObject1をプロパティ名として指定するとkeyObject1が暗黙的に文字列化して`[object Object]`がkey名になる。
	- 例外的にSymbolは文字列化されない
	- Mapオブジェクトはオブジェクトをキーとして扱える。
```
const obj = {};
const keyObject1 = { a: 1 };
const keyObject2 = { b: 2 };
// どちらも同じプロパティ名（"[object Object]"）に代入している
obj[keyObject1] = "1";
obj[keyObject2] = "2";
console.log(obj); //  { "[object Object]": "2" }
```

- オブジェクトの静的メソッド
	- インスタンスの元となるオブジェクトから呼び出せるメソッド
	- オブジェクトの列挙
		- Object.keys
		- Object.values
		- Object.entries
	- オブジェクトのマージと複製
		- Object.assign
			- あるオブジェクトを別のオブジェクトに代入できる
			- `Object.assign(target, ...sources)`
			- 1つ以上のsourcesオブジェクトをtargetオブジェクトへコピー

- spread構文でのマージ
	- 配列を展開するように、オブジェクトのプロパティを展開
```
const objectA = { a: "a" };
const objectB = { b: "b" };
const merged = {
    ...objectA,
    ...objectB
};
console.log(merged); // => { a: "a", b: "b" }
```

- JavaScriptライブラリ
	- npmというパッケージ管理ツールで公開されている
	- 言語仕様で定義されている機能が最小限

- 全てのオブジェクトはObject.prototypeプロパティに定義されたprototypeオブジェクトを継承している
	- このオブジェクトに組み込まれているメソッドをプロトタイプメソッド
	- インスタンスからprototypeオブジェクト上に定義されたメソッドを呼べることをプロトタイプチェーン

- Object.hasOwnとinの違い
```
const obj = {};
// `obj`というオブジェクト自体に`toString`メソッドが定義されているわけではない
console.log(Object.hasOwn(obj, "toString")); // => false
// `in`演算子は指定されたプロパティ名が見つかるまで親をたどるため、`Object.prototype`まで見にいく
console.log("toString" in obj); // => true
```

- 隙間のある配列
	- 値を省略することで、未定義の要素を含めることができる
	- 隙間のあるものを疎な配列
	- ないものを密な配列
```
// 未定義の箇所が1つ含まれる疎な配列
// インデックスが1の値を省略しているので、カンマが2つ続いていることに注意
const sparseArray = [1, , 3];
console.log(sparseArray.length); // => 3
// 1番目の要素は存在しないため undefined が返る
console.log(sparseArray[1]); // => undefined
```

- 配列の要素に相対的なインデックスを指定してアクセスする
	- pythonでは末尾にアクセスするには`array[-1]`でよかった
	- 同じようにするには.atメソッドを使う
	- この-1ってlength-1を表してたのか

- hasOwnを使ってundefinedなのか、未定義の要素なのかを判定する
	- 要素自体が存在していれば、undefinedという値
	- 存在していなければ未定義
		- ここでundefinedと結果が出力されるが、要素は存在していないことに注意

- 配列から要素を検索
	- array.indexOf()
		- 先頭から探索して見つかった要素のインデックスを返す
	- array.lastIndexOf()
		- 末尾から探索
- 配列から条件に一致する要素を取得
	- find
	- findLast
- 指定範囲の要素を取得
	- Arrayのsliceメソッド
- 真偽値を取得
	- includesメソッドは含まれているかどうかの真偽値を返す
- 追加と削除
	- pushメソッドで末尾に追加
	- popメソッドで要素を削除し、その要素を返す
	- 先頭要素に追加するにはunShift
	- 削除するにはshift
- 配列同士を結合
	- concatメソッド
	- spread構文(...)を使うと、配列リテラル中に既存の配列を展開できる
	- `const newArray = ["X", "Y", "Z", ...array];`
- 配列から任意の要素を削除
	- spliceメソッドを使う
	- 削除した要素を自動で詰めることができる

- 破壊的なメソッドと非破壊的なメソッド
	- 破壊的なメソッドは、配列オブジェクトそのものを変更してそのまま返す
	- 非破壊的なメソッドは、配列オブジェクトのコピーを作成してから変更を加えて、そのコピーしたものを返す
	- pushは破壊的
	- concatは非破壊的


## 次やること
- JavaScript Primer
## 感じたこと
- 読んだ後に、そのページの一問一答を作って解いてみるといいかもしれない

## 学習時間

| today | total |
| ----- | ----- |
| 5h    | 1061h |

## 取り組んだ課題一覧
- JavaScript Primer
	- 第1部 基本文法
## わかったこと
- toから始まるのは非破壊的メソッドがち

- 破壊的なメソッドは元の配列も変更してしまうので、意図しない副作用が発生し、バグの原因となるので、非破壊的なメソッドをまずは検討する

- 配列を反復処理するメソッド
	- どれもコールバック関数を引数にもつ
	- forEach
		- 配列の要素を先頭から順にコールバック関数へ渡して、コールバック関数が返す値を新しい配列として返す
	- map
	- filter
		- コールバック関数がtrueを返した要素だけを集める
	- reduce
		- 配列から配列以外の値を作成する
		- 例として配列の要素を全て合計した値などを求めることができる

- テンプレートリテラル
	- バッククォートを使うと、文字列中に改行を使える
	- 改行は\nとして出力される
	- `${変数名}`で変数を評価できる

- 文字列の分解と結合
	- 文字列を配列へ分解する
		- splitメソッド
		- 区切り文字を指定して分解
	- 配列の要素を結合して文字列にする
		- join
		- 区切り文字を指定して結合

- ラッパーオブジェクト
	- プリミティブ型の値をインスタンス化したオブジェクト
	- Boolean
	- Number
	- BigInt
	- String
	- Symbol
	- というラッパーオブジェクトがある
	- ラッパーオブジェクトはobject型

- 自動変換
	- "string"等文字列は自動で`new String("string")`のようなラッパーオブジェクトへ変換される
	- またメソッドを呼び出すときにリテラルがラッパーオブジェクトへ変換される
	- 明示的にラッパーオブジェクトを扱う利点はない

- 関数スコープ
- ブロックスコープ

- スコープチェーン
	- ネストされたブロックで外側のブロックはOUTER, 内側のブロックはINNERと呼ぶ
	- INNERブロックからOUTERブロックスコープの変数を参照できる
	- 変数を参照する際には現在のスコープから外側のスコープへと順番に変数が定義されているかを確認していく。
	- どんどん上のスコープへ順番に変数が定義されているか探す仕組みをスコープチェーン

- グローバルスコープ
	- プログラム直下にある最も外側のスコープ
	- ここで定義した変数はグローバル変数
	- それ以外に、プログラム実行時に自動で定義されるビルトインオブジェクトがある
		- undefinedなど

- 変数の隠蔽
	- 内側のスコープで外側のスコープと同じ名前の変数を定義すること
		- 避けるために無闇にグローバルスコープへ変数を定義しないこと

- 関数宣言と巻き上げ
	- functionキーワードの関数宣言もvarと同じく、グローバルスコープの先頭に巻き上げられる。
```
// `hello`関数の宣言より前に呼び出せる
hello(); // => "Hello"

function hello(){
    return "Hello";
}

// 解釈されたコード
// `hello`関数の宣言が巻き上げられる
function hello(){
    return "Hello";
}

hello(); // => "Hello"
```

- クロージャー
	- 外側のスコープにある変数への参照を保持できる、という関数が持つ性質
	- 関数内から特定の変数を参照し続けることで関数がまるで関数が状態を持っているように振る舞う
	- myCounter -> increment -> count
		- のようにcount変数を参照するものがあるので、count変数は自動的に解放されずに、値は保持し続けられる
	- 静的スコープとメモリ管理という2つの性質で実現している

- 静的スコープ
	- JavaScriptのスコープにはどの識別子がどの変数を参照するかが静的に決定される
```
const x = 10; // ＊1

function printX() {
    // この識別子`x`は常に ＊1 の変数`x`を参照する
    console.log(x); // => 10
}

function run() {
    const x = 20; // ＊2
    printX(); // 常に10が出力される
}

run();
```

- メモリ管理の仕組み
	- ガベージコレクション
		- どこからも参照されなくなったデータを不要なデータと判断して自動的にメモリ上から解放する仕組み

- 関数とthis
	- thisは読み取り専用のグローバル変数のようなもの
	- thisの参照先は条件で異なる
		- 実行コンテキスト
		- コンストラクタ
		- 関数とメソッド
		- Arrow Function
	- thisが実際に使われるのはメソッド

- メソッドの定義
```
const obj = {
	// メソッドの短縮記法で定義したメソッド
	method() {
	}
};
```
- thisの挙動
	- Arrow Function以外の関数におけるthis
		- 実行時に決まる値
		- thisは関数に渡される暗黙的な引数

- class構文
	- クラスを作るための関数定義や継承をパターン化した書き方
	- classキーワードを使う
	- クラスは必ずコンストラクタを持ち、constructorという名前のメソッドを定義する
		- クラスからインスタンスを作成する際に、インスタンスに関する状態の初期化を行う
		- コンストラクタの処理が不要の場合は省略OK

- クラス式
	- クラスを値として定義する方法
	- 無名関数と同じ

- インスタンス化
	- newを使ってインスタンス化
	- コンストラクタ関数におけるthisはインスタンスを示すオブジェクト
	- xとyプロパティに値を設定
```
this.x = x;
this.y = y;
```

- コンストラクタにreturnでオブジェクトを返すのは避けるべき

- プロトタイプチェーン
	- インスタンスからプロトタイプオブジェクトに定義されたメソッドやプロパティを参照できる
	- オブジェクトの継承元となるプロトタイプオブジェクトを内部プロパティに保持する
	- インスタンス自身がプロパティを持っていなければプロトタイプオブジェクトに探索を広げる

- クラスのプロトタイプメソッド
	- クラスに対して定義したメソッドはクラスの各インスタンスから共有されるメソッドとなる

- クラスのアクセッサプロパティの定義
	- プロパティの参照 getter
		- get プロパティ名とつける
	- プロパティの代入 seter
		- set プロパティ名とつける
	- プロパティ名へアクセスするだけで、getterが呼び出される
	- プロパティに値を代入するとsetterが呼び出される

## 次やること
- JavaScript Primer
## 感じたこと
- JSPrimerにあるNotebook LLMが便利

## 学習時間

| today | total |
| ----- | ----- |
| 5h    | 1066h |

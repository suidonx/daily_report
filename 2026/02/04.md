## 取り組んだ課題一覧
- JavaScript
	- ガチで学びたい人のためのJavaScriptメカニズム
## わかったこと
- クロージャー プライベート変数
	- グローバル変数で値を管理すると、関数を使わずとも、外部から変数の値を書き換えることが可能
	- 外部から書き換えるのを防ぐため、プライベート変数化する
		- factoryメソッドを作る
		- 変数を閉じ込めたクロージャーを作って返す関数
```
function incrementFactory() {
	// 変数をとじこめる
	let num = 0;
	
	function increment() {
		num++;
	}
	return increment;
}

const increment = incrementFactory;
// この関数からでしかnumにアクセスできない
increment();

// incrementとは違うインスタンスなので変数の値も共有ではない
const increment2 = incrementFactory;
```

- クロージャー 動的な関数を生成
	- ファクトリー関数に引数を渡すと動的な関数が作れる

- 即時関数
	- 関数定義と同時に一度だけ実行される関数
	- ()はグループ化
	- 即時関数では()が必要
		- syntax errorが出てしまうので、でないようにするため()をつける
		- 関数宣言してるのに、関数名がない、というエラー
	- パブリックな変数、関数とプライベートなものを明確に分けるときに使う

- 演習問題
	- varは宣言するとホイスティングされるので、var v;が先頭に来流。そのため、vがundefinedになる。
		- 後ろの行はv = "val2";となるため、"val2"と出力される
	- ブロックスコープは関数宣言はすり抜ける、let, constはスコープ外部絡みれない
		- クロージャーができる
	- メソッド定義
		- plus() {};, minus() {};という書き方でOK

- var
	- varはブロックスコープを無視する
	- varは再代入ができる。var a = 0; var a = 1;でもエラーにならない
	
- 型
	- JavaScriptは動的型付け言語
	- 値で型が決定し、実行してみて初めて型が決定される
	- マイナス記号は数値の計算でしか使われないため、- "1"は-1と数値に変換される
	- nullは0、trueは1と暗黙的に変換される

- AND条件
	- falsyの値があれば、それを返す。
	- 全てtrueならば最後の条件の値を返す
	- `name && hello(name);`
		- nameが正しい値の時にhello関数を実行する処理
		- 不正なときは実行しない
	
- OR条件
	- truthyが見つかったらそこで結果を返して終わり
	- そうでない場合は、条件の最後のfalsyを返す
	- `name = name || "Tom";`
		- デフォルト値を作れる

- プリミティブ型とオブジェクト
	- "123"はメモリに値として保持される。
	- アドレスにある"123"を"12"などに変更することができない
		- イミュータブルな性質
	- a = "123"の時aは値を保持する
	- b = {prop: "hello"}
		- bはオブジェクトへの参照を保持している
		- オブジェクトそのものを保持しているわけではない
		- propは"hello"への参照を持つ
		- オブジェクトは名前付き(プロパティ)の参照を持つ入れ物
	- 変数をコピーした時に違いが出る
		- 値をコピーするか、オブジェクトへの参照をコピーするか

- 分割代入
	- オブジェクトから特定のプロパティを抽出して宣言して、変数の初期値として代入される。
	- `let {a, b} = object;`
	- objectが持つプロパティa, bの値が変数a, bに格納される
	- プロパティが持つ参照先がコピーされて新しい変数に格納される

- オブジェクトの比較
	- a = {}; とb={};を比較すると、オブジェクトの参照を比較しているのでfalseになる

- 演習問題
	- "false" == falseはfalse
		- 暗黙的な型変換は行われない
		- "false"はtruethyな値として扱われる

- 値がないことはa = nullで定義, a = undefinedとはしない。

- arguments
	- このオブジェクトには実引数が入る
	- 実引数の数がよくわからない時、仮引数の数を合わせるのが困難
		- argumentsを使って任意の数の引数を受け取ることができる
		- しかし、最近ではrest parametersを使うので使われない。
			- 可変長引数を受け取るために3点ドットを使う
			- `...args`で引数が配列に格納される

- 関数はオブジェクト
	- 特に、実行可能なオブジェクトが関数
	- 重要なコンセプト
	- 関数にもプロパティを定義可能

- コールバック関数
	- 処理を切り分けて部品化する
	- 再利用可能になって嬉しい

- this
	- メソッドの外側にあるプロパティにアクセスしたいときに、this.nameというようにアクセスしがち
	- person.nameというようにthisがなくてもOKだが、thisを使うのが普通
- thisの参照先
	- オブジェクトのメソッドで実行
		- thisは呼び出し元のオブジェクト
	- 関数で実行
		- thisはグローバルオブジェクトつまりWindowオブジェクト
	- bind
		- person.hello.bind(person)とするとthisがpersonオブジェクトを示す
		- 引数やthisを固定した新しい関数を作れる
		- bindによるthisの束縛

- call, apply
	- thisや引数の参照先を変更
	- 同時に関数を実行する
	- a.apply(thisの対象, \[引数の配列])
	- a.call(thisの対象, 引数1, 引数2, ..., )
	- a.apply()やa.call()で関数を実行しつつ、引数を変更できる
	- apply
		- 配列を展開してくれる使い方をしていた。
		- ES6よりスプレッド演算子で展開できるようになり、この使い方はしなくなった
			- ...arrayでarrayを展開できる

- アロー関数と無名関数
	- this, arguments, new, prototypeが無名関数にはある
	- アロー関数では使えない

- アロー関数とthis
	- thisがないので、アロー関数でthisを使うとレキシカルスコープのスコープチェーンを辿り、グローバルオブジェクトのWindowオブジェクトがthisになる。

- 演習
	- コールバック関数を渡しているから、関数コンテキストになり、thisはグローバルオブジェクト
	- 定義時点でレキシカルスコープのthisを定義する
	- コールバック関数に引数を渡すときはbindを使う


## 次やること
- JavaScript
	- ガチで学びたい人のためのJavaScriptメカニズム
## 感じたこと
- アロー関数と関数、オブジェクトの中のメソッドのthisの違いで混乱する。
## 学習時間

| today | total |
| ----- | ----- |
| 6h    | 1094h |

## 取り組んだ課題一覧
- JavaScript
	- ガチで学びたい人のためのJavaScriptメカニズム
## わかったこと
- a = b = 1
	- =演算子は右から左に評価されるのでb=1 , a = b, a = 1と評価
- ブロックスコープとループ文
	- 1ループごとにブロックスコープが切り替わっている
	- 名前は同じだが、各ループごとに違う値としてメモリに保存されている
- カンマ区切りで変数を定義
	- let v, i = 0;
	- これはlet v; let i = 0;と同じ効果
- for ... inのループ
	- 順不同
	- prototypeに設定したプロパティも取得する
		- ループから外したいときはhasOwnPropertyを使って条件分岐させる
- enumerable
	- ループで列挙の対象にするかどうかのフラグ
- イテレーター
	- 反復可能オブジェクト
	- 反復操作に使うオブジェクト
	- 決められたルールで定めたメソッドを定義したイテレーターオブジェクト
		- next()で{value, done}を返す
		- doneは終了条件
		- for of の裏側
- ジェネレーター
	- イテレーターを生成する関数
	- 'function*'
	- ＊をつけるとジェネレーター関数になり、yieldキーワードを使える
	- yieldが呼び出されるとジェネレーター関数で待機する
	- イテレーターの構文よりも短く書ける
	
- for ofはイテレーターの挙動に依存する
- Map, Set
	- データを管理する入れ物
	- コレクション
	- mapは`[[Entries]]`というところに格納されている、値の管理の仕方が違う
		- mapは配列のなかにobjectが入っている
		- for ofで取得できる
	- set
		- for ofで取得できる
		- 順番は挿入順
		- 重複排除
- スプレッド演算子
	- イテレーターの動作に基づいて展開
	- 反復可能なオブジェクトに対して使える
- 演習
	- ジェネレーターの概念のための理解でイテレーターのnextメソッドを作る
	- 実用面ではジェネレーターを使う
	- yield 値はdone: falseとvalue: 値を意味する。
	- 分割代入
		- genStep({min, max, step})で実引数がオブジェクトの時、min, max, stepプロパティの値が代入される。
	- `function* genStep({ min = 0, max = 20, step = 1 } = {}) {`
		- ={}は引数そのもののデフォルト値
		- genStep()とすると分割代入をしようとしてエラーになる
		- undefinedをオブジェクト化してminなどのプロパティを探そうとしてエラー
		- `Uncaught TypeError: Cannot read properties of undefined (reading 'min')`になるからそれを避けるための={}
- Thread
	- 連続して実行される1本の処理の流れ、系
	- メインスレッド
		- JavaScript -> レンダリングを行う
		- 重い処理があると画面が更新されなくなる。fpsが下がる。

- 同期処理
	- メインスレッドでコードが順番に実行される
	- 一つの処理が終わるまで次の処理へ進まない

- 非同期処理
	- メインスレッドから処理が切り離されてメインスレッドが空く

- タスクキュー
	- 実行待ちの非同期処理の行列
	- 非同期処理はタスクキューに並ぶ

- コールスタック
	- コールスタックが空き次第、タスクキューの関数がコールスタックに積まれていく
	- メインスレッドが空くというのはコールスタックがからになること。
	- グローバルコンテキストがまずコールスタックに積まれる
		- pop次第、タスクキューからコールスタックへ積まれて処理が実行

- 非同期処理のチェーン
	- コールバック関数をネストで記述していくと連続した非同期処理を書ける
	- しかし、可読性が低い

- Promise
	- より直感的に非同期処理を書くための構文
	- new Promise(同期処理)でthen, catch, finallyは非同期処理
	- resolve()が呼ばれるとthenメソッドに渡したコールバック関数が実行
		- thenメソッドをチェーンすることで、階層が深くならない
	- 最後にfinallyメソッドに渡したコールバック関数で終了、共通処理を記述する
	- reject()が発生した時はcatchメソッドのコールバック関数で処理

- Promiseチェーン
	- thenで繋げていく
	- それぞれのthenは前のthenが返したPromiseがfulfilledになるまで待機される

- Promiseの並列処理
	- Promise.allを使うと引数のコールバック関数が全て終了したらthenメソッドが行われる
	- Promise.raceを使うと、引数のコールバック関数のどれか1つが終了したらthenが呼ばれる
- マクロタスク
	- タスクキュー
	- setTimeout
- マイクロタスク
	- ジョブキュー
	- 別で存在する非同期処理の待ち行列
	- マイクロタスクがはじめに実行され、次にマクロタスクが実行される
	- マイクロタスクが空になったら、マクロタスクが実行される
		- マクロタスク実行後にマイクロタスクに積まれたらマイクロタスクを実行する
	- Promiseがpendingの時、resolve()を呼ぶことでfulfilledに遷移する
		- fulfilledの時、thenのコールバック関数がジョブキューに積まれる
		- thidのコールバック関数はPromise内部でPromiseの状態が遷移するのを待機している

- async
	- Promiseを返却する関数の宣言を行う
		- return v;でPromise.resolve(value)を返すような感じ
	- async/awaitはPromiseチェーンのシンタックシュガー
- await
	- Promiseを返却する関数の非同期処理が完了するまで待機する
	- await 非同期処理
	-  awaitを使う場合は、asyncがないとエラー
	- await は Promise が fulfilled になるまでasync関数の流れを中断して、fulfilled になったらジョブキューとして再開する

- fetch
	- HTTPリクエストを送信して、レスポンスをPromiseとして返すWeb API
	- Promiseがfulfilledになった時、thenメソッドのコールバック関数が実行

- モジュール
	- コードを整理、分割してメンテナンスしやすくする仕組み
	- モジュール管理システム
	- CommonJS(CJS)
		- node.js上でモジュールを管理
		- require / exportsでモジュールを読み込む、露出
	- ES Module
		- ブラウザ側でモジュールを管理
		- import / export

- モジュールコンテキスト
	- ESモジュールを使うとグローバルコンテキストがモジュールコンテキストに。
		- thisがundefinedという点が違う
		- オブジェクトのメソッドを呼び出した時のthisは変わらずオブジェクト自身

- モジュールスコープ
	- ESモジュールの場合、スクリプトスコープがモジュールスコープになる。
	- ファイル単位のスコープ
	- 外部からアクセスするにはimport/exportが必要
		- グローバル汚染しない
		- 名前衝突しない

- html要素のscriptタグ
	- type="module"
		- deferが自動的に付与
		- 複数回、モジュールをimportした時に1回だけ実行される
		- strict modeになる
	- defer
		- 非同期処理でjsファイルを読み込む

- use strict
	- コードのセキュア化、意図せぬバグの予防
	- モジュールスコープではuse strict

- ダイナミックインポート
	- 必要になったタイミングでモジュールを非同期関数で読み込む仕組み
	- 通常のimportはファイル読み込み時に実行する
## 次やること
- JavaScript
	- ガチで学びたい人のためのJavaScriptメカニズム
## 感じたこと
- Promiseの流れがなんか難しい
- コード色々書いてみないと見えてこない気がする

## 学習時間

| today | total |
| ----- | ----- |
| 6h    | 1106h |

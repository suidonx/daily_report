## 取り組んだ課題一覧
- React
	- Reactに入門した人のためのもっとReactが楽しくなるステップアップコース完全版
## わかったこと
- React Router
	- BrowserRouterタグ
		- アプリ全体をルーティング対応にするためのコンポーネント
		- これで囲むとLinkタグ、Switchタグ、Routeタグなどが使える
			- SwitchタグはReact Router v6でRoutesに置き換え
		- URLの変更を監視、現在のURLに応じて表示するコンポーネントを切り替え
		- ページリロードなしで画面遷移
	- Linkタグ
		- aタグの代わり
	- Switch、Routesを使ってルーティングによって表示するコンポーネントを出しわけする
- SwitchとRoute
	- v5でのやり方
	- 前方一致で検索、完全一致ではなかった
	- exactを使う必要がある
- Routeタグ
	- v6でのやり方
	- exact不要
	- 現在のURLと、Routeのpathを比較して、最も一致度が高いRouteを選ぶ
- elementを親コンポーネントに指定すると、意図せぬ挙動に。
	- 共通レイアウトを親コンポーネントに指定して、親コンポーネント上で子コンポーネントを表示させたいときに使う。
	- Outletで使える
```
<Route path="/page1" element={<Page1 />}>
    <Route path="detailA" element={<Page1DetailA />} />
    <Route path="detailB" element={<Page1DetailB />} />
</Route>
```
- ネストの書き方
	- /page1/detailAでPageDetailAコンポーネントをレンダリング
```
<Route path="/page1" />}>
	<Route index element={<Page1 />}
    <Route path="detailA" element={<Page1DetailA />} />
    <Route path="detailB" element={<Page1DetailB />} />
</Route>
```
- renderを使う方法
	- RouteでelementにJSXとしてpropsを渡すのがv6
- ルート定義の分割
	- Routeタグで書いたルーティングの設定を別ファイルに切り出してコンポーネント化する
		- 規模が大きい場合は、別ファイルで書いたとしても、見にくい
- 配列で渡してmapでルート定義する
	- indexは親ルートと一致するURLかどうか
```
        <Route path="/page1">
          {page1Routes.map((route) => (
            <Route
              index={route.index}
              path={route.path}
              element={route.children}
            />
          ))}
        </Route>
```
- useParams
	- URLパラメーターを受け取る
	- コロンをつける
```
export const page2Routes = [
  {
    index: true,
    children: <Page2 />,
  },
  {
    path: ":id",
    children: <UrlParameter />,
  },
];
```
- useLocation
	- 現在のURL情報を取得できる
	- クエリパラメータの取得
- stateを渡すページ遷移
	- React router v5ではこのようにオブジェクトで渡す
	- v6ではpropsとして渡す
```
<Link
  to={{
    pathname: "/page1/detailA",
    state: arr
  }}
>
```
```
<Link
  to="/page1/detailA"
  state={arr}
>
```
- useHistory
	- React router v6では削除されている
	- useNavigateを使う
		- navigate("/path")

- アトミックデザイン
	- コンポーネント化と相性が良い設計思想
	- 画面要素を5段階に分ける
	- 初めからコンポーネントを分けない
		- 定期的に無理なくリファクタリング
	- 要素の関心を意識しながらpropsを定義、コンポーネントの分割
- グローバルなstate
	- stateをpropsで渡す方法は大規模になると面倒
	- コンポーネント分割しているとpropsをバケツリレーで渡すことになって複雑になる
	- どのコンポーネントからでもアクセスできるstate
- Contextでのstate管理
	- providers
		- 値を提供するもの
		- コンテキストを提供
	- createContext
		- コンテキストを作成
	- useContext
		- 作成したコンテキストを引数にして、コンポーネント内で利用
- useContextの注意点
	- コンテキストの値が変更された時、それを参照しているコンポーネントは再レンダリングされる
		- 親コンポーネントが再レンダリングされると、子コンポーネントが再レンダリングされるから
		- memo化して不要なレンダリングを防ぐ
- Recoil
	- グローバルstate管理ライブラリ
	- 開発が止まっており、今はZustand、Jotaiが主流
- axios
	- fetchと比べ、JSON変換を自動でやってくれる
	- `const res = await axios.get("/api/users");`
	- fetchではres.json()が必要だが、resのまま利用可能
## 次やること
- React
	- Reactに入門した人のためのもっとReactが楽しくなるステップアップコース完全版
## 感じたこと
- styled-componentsでCSSを書くのは大変そう
- tailwindでclassNameに書いていく方が楽そうな気がした。

## 学習時間

| today | total |
| ----- | ----- |
| 5h    | 1137h |

## 取り組んだ課題一覧
- React
	- GitHub Pagesにデプロイする方法の記事を作成
	- 【Reactアプリ開発】を見る
## わかったこと
- npm run
	- npm scriptsというタスク実行機能
	- package.json内の"scripts"を実行する
- Promiseオブジェクトの復習
	- Promiseオブジェクト
		- 非同期処理が成功したか失敗したかの状態を表すオブジェクト
	- Promise.thenやcatchで成功時、失敗時に呼び出される処理をコールバック関数として登録できる
		- thenメソッドは(resoveの時の処理, rejectの時の処理)と二つ引数を持てるが、わかりにくいため、reject時はcatchメソッドが使われる
	- >`Promise`インスタンスの状態が変化したときに、一度だけ呼ばれるコールバック関数を登録するのが`then`や`catch`メソッドとなります。
```
// `Promise`インスタンスを作成
const promise = new Promise((resolve, reject) => {
    // 非同期の処理が成功したときはresolve()を呼ぶ
    // 非同期の処理が失敗したときにはreject()を呼ぶ
});
const onFulfilled = () => {
    console.log("resolveされたときに呼ばれる");
};
const onRejected = () => {
    console.log("rejectされたときに呼ばれる");
};
// `then`メソッドで成功時と失敗時に呼ばれるコールバック関数を登録
promise.then(onFulfilled, onRejected);
```
- Promise.resolveやPromise.reject
	- 静的メソッドはFulfilled、Rejected状態のPromiseインスタンスを作成する
	- new Promiseをして、resolve(), reject()を読んだ時と同じ状態のインスタンスを作るシンタックスシュガー
	- >`Promise.resolve`や`Promise.reject`は短く書けるため、テストコードなどで利用されることがあります。
- Promiseチェーン
	- thenやcatchメソッドで新しいPromiseインスタンスを返すことで複数の非同期処理を順番に扱う記法
	- Promiseが失敗しない限り、thenで成功時のコールバック関数を呼ぶ
- Promiseチェーンではthenやcatchがreturnした値を次のコールバック関数へ引数として渡す
- catch内で値をreturnすると、Fulfilled状態のPromiseインスタンスが次に渡される
	- catch内でthrowするとRejected状態のPromiseインスタンスが発行
- Async Function
	- Promiseチェーンの不恰好な見た目を解決するために導入
	- 必ずPromiseインスタンスを返す
	- returnした値の代わりに、Promise.resolve(返り値)を返す
- Promiseインスタンスはresolve, rejectを呼ばないとPending状態から変わらない
- 例外を投げる、エラーが出た場合はrejected状態になる
- Async関数の場合は、returnしてもしなくてもfulfilledに変わる、returnなしだとundefinedを持つ
- ここでfetchを見るとresolveを使わずともthenに登録した処理が実行されている
	- fetchはHTTPリクエストを送信して、成功してレスポンスを受け取るとfulfilled、失敗でrejectedに遷移するから
- Promise.allは中身のPromiseが全てFulfilled状態になれば、本体もFulfilledとなり、配列を返すようになる
## 次やること
- React
	- 【Reactアプリ開発】を見る
## 感じたこと
- async関数は通常のPromiseインスタンスをnewするのと比べ、自動でPromiseインスタンスの状態を決定してくれるという違いにようやく気づく。

## 学習時間

| today | total |
| ----- | ----- |
| 6h    | 1170h |

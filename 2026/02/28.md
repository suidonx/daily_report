## 取り組んだ課題一覧
- TypeScript
	- ハンズオンで学ぶTypeScript
- JavaScript練習問題
## わかったこと
- npxコマンド
	- パッケージをインストールせずに実行する
	- すでにインストールしているモジュールを実行
- >Node.jsはv23.6.0以降ではTypeScriptの型注釈などの情報を無視してJavaScriptとして実行できるようになりました。
	- 実際に`node index.ts`を実行できた。
	- しかし、引数などに間違った型が使用されていても、コンパイルエラーにならない
	- ランタイムエラーにはなる
	- 小規模な開発ではnodeでもありだが、tscコマンド	
- それ以前のverではts-nodeを使う
- ts-node-dev
	- ts-nodeよりも高速
	- `ts-node-dev --respawn --transpile-only server.ts
		- >特に大規模なコードベースでは、`--transpile-only`開発ワークフローでは一般的なフラグを常にオンにして実行することを検討してください。これにより、処理速度が大幅に向上します。
		- --respawnでファイルの変更を監視
	- https://qiita.com/sa9ra4ma/items/67ab5ac6fea3e5f065b0
- TypeScriptの嬉しさ
	- ソースコードを動かさなくとも、エラーに気づける
	- 型間違いの値を代入しようとしてる時など。
	- 型安全を確保して、意図せぬ値が混入するといったバグを減らす
- import, exportをつけない場合グローバルコンテキストに追加されるので、他ファイルと変数名、関数名が衝突する
	- import, exportをつけるとモジュールシステムを利用できる
	- モジュールスコープになり、安全になる
- 二次元配列の型
	- `number[][]`
	- `string[]`と法則は同じで配列の要素+\[\]っぽい
- tuple
	- 配列のように要素の型が同一ではない
	- 型の順序を保証する
	- 型推論で出ない、以下のようにUnion型になる。
```
// union型
let profile: (string | number)[] = ["john", 32];
// これもunion型
let profile3 = ["john", 32];
// 順番も指定するtuple型
let profile2: [string, number] = ["john", 32];
// なのでこれはエラーが出る
profile2 = [23, "john"];
// これもエラー、要素数が2個でないから
profile2 = ["john", 32, "do", 2]
```
- null, undefinedは型推論が働かない
- Errorが投げられるので、値が返らないのでnever
```
function throwError(): never {
  throw new Error("error");
}
```
- Type Example = typeof example1というように取り出した型を型エイリアスとして宣言できる
	- interfaceも同じようにobject型に名前をつけることができる。interfaceはclassで使う
- unknown型
	- anyを型安全にした不明型
	- unknown型の値は具体的な型へ代入できない
	- プロパティへのアクセスができない
	- 条件分岐でtypeofを使うとコンパイラはunknownの中身の型がわかり、その条件の中では利用できる
		- 型ガードという
- enum
	- 関連する一連の数値または文字列値の集まりを定義する。
	- 各要素が連番を持つのが特徴
		- Color.Red // 0
		- 連番と文字列や数値を1対1で対応づけたい時に使える
```
enum Color {
  Red,
  Green,
  Blue,
}
```
- reduceメソッド
```
const array = [1, 2, 3, 4];

// 0 + 1 + 2 + 3 + 4
const initialValue = 0;
const sumWithInitial = array.reduce(
  (accumulator, currentValue) => accumulator + currentValue,
  initialValue,
);
```
- initialValueを指定したときはそれが初期値accumulatorにな理、0番目の要素がcurrentValue
- ない場合は、0番目の要素が初期値accumulator、1番目の要素がcurrentValue
- コールバック関数の戻り値がaccumulatorに入る
- >関数シグネチャとは、どのような引数を取るか、どのような戻り値を返すかといった関数の型のことです。要するに、異なる引数や戻り値のパターンがいくつかある関数をオーバーロード関数と言います。
	- オーバーロード関数にはanyでOK
		- シグネチャで関数の型を用意しているからオーバーロード関数には用意した引数の型しか来ない。門番。
	- オーバーロード関数の実体は１つ、条件分岐で複数のシグネチャに対応した処理を書く
- クラスのstatic field
	- staticつける
	- ない場合はインスタンスフィールド
```
class Config {
  // 静的フィールド
  static apiEndpoint = "https://api.example.com";
}
```
- アクセス修飾子
	- private、自身のクラスのみアクセス可能
	- protected、自身のクラスとサブクラスからアクセス可能
	- オーバーライド時にアクセスを緩くするのは狭くするのはNG
		- リスコフの置換原則を壊す
		- 子は親の代わりとしてつかえなければならない
			- 親コーヒー→子カプチーノ
			- コーヒーが欲しい人にカプチーノを出しても問題ないということ
- Array.prototype.some()
	- 配列の中の要素が1つでもコールバック関数でtrueを返したらtrue
- for in
	- オブジェクトのキーを取得
- Mapオブジェクト
	- 追加した順番を保持する
## 次やること
- ハンズオンで学ぶTypeScript

## 感じたこと
- Javaっぽい仕様多め

## 学習時間

| today | total |
| ----- | ----- |
| 6h    | 1199h |

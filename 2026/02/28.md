## 取り組んだ課題一覧
- React
	- ReactでTrelloクローンを作る
		- Vercelデプロイまで
- Web セキュリティ
	- CORS
	- 主要な攻撃とその対策について
- TypeScript
	- TypeScriptの基本
## わかったこと
- Vercelを使ったデプロイ方法
- CORSとは
	- Cross-Origin Resource Sharing
	- オリジン間リソース共有
		- リソース＝データ
- オリジンとは
	- ほぼURL
	- スキーム(https)＋ドメイン+ポート番号
- CORSエラー
	- URL間でデータを共有していくこと
	- やろうとしてもエラーになる
	- そもそも同じオリジン間でしかリソースのやり取りを許可していない（デフォ）
	- 同一生成元ポリシー
- どういう時エラー
	- サブドメインがつくと、CORS policyエラー
	- 全く違うドメインは当然、CORS policyエラー
	- ポート番号が違うとエラー
- なぜCORSがあるの？
	- ユーザーを守るため
	- 悪意あるサイトとのデータ共有を防ぐため
		- 金銭の送金とか。
- CORSエラーの解決
	- サーバー側で許可出しをする
	- ホワイトリスト方式でどのオリジンからのアクセスを許可するか決める
	- Access-Control-Allow-Origin
- nodemon
	- ディレクトリ内のファイルの変更を検知すると、サーバーが再起動されるツール
- express
	- node.jsのバックエンドフレームワーク
- XSS
	- webサイト上に不正なスクリプトを配置して、セッションハイジャック攻撃などを実現する
		- 脆弱性をついてクエリパラメータや入力フォームにスクリプトを仕込む
	- 対策
		- HTTPレスポンスヘッダで文字コードを指定
			- ブラウザが誤った文字コードで解釈し、エスケープをすり抜けることがある
		- `"` （ダブルクォート） → `&quot;`
		- `'` （シングルクォート） → `&#39;`
		- といった無害な文字に変換するエスケープ処理をする
- セッションハイジャック
	- セッションIDを乗っ取り、そのユーザーになりすます。
	- セッションIDはログイン成功した時に、サーバーからブラウザのcookieなどにセッションIDを渡し、次回通信する際に、サーバーへセッションIDを渡すことで通信相手を特定するもの
- SQL injection
	- `select * from users where id = <USER_ID> and password = <PASSWORD>`のようなSQLでログイン処理をするとして、ユーザーIDとパスワードを入力フォームで受け取ると
	- `OR 1 = 1; --`とユーザーIDに入力すると、where条件が必ずtrueになり、usersテーブルの情報を全て取得できてしまう。
	- なので、ユーザーからの入力をただの文字として受け取ると言った対策が必要
- window.location
	- ブラウザの現在位置の情報を持つオブジェクト
- エスケープ
	- 特別な意味を持つ文字をただの文字として扱う、もしくは文字を置き換える
		- \<, \>, \"など
	- 置き換えないと、SQLインジェクションの`OR 1 = 1 --`のように;で区切られる。ただの文字として扱うことで、防げる。
- サニタイジング
	- 入力データから有害な部分を無効化する
	- 保険的処理、エスケープをして脆弱性を作り込まないようにするのが良い。
- パスワードの保存
	- 平文で保存しない、復元できない加工済みの値を保存
	- ハッシュ
		- ハッシュだけではレインボーテーブル攻撃に対応できない
		- ハッシュは同じ文字列から生成すると同じハッシュになる
		- レインボーテーブル攻撃
			- パスワードとハッシュの1対1の表を作り、DBから窃取したハッシュを検索してパスワードを特定
	- ソルト
		- パスワードにランダムな文字列を追加してからハッシュ化する
	- ストレッチング
		- ハッシュを何千回も繰り返す
- CSRF
	- ユーザーがログインしている状態を悪用して意図せぬ操作を実行させる攻撃
	- 悪意あるサイトの罠ページから、攻撃リクエストをログインしているサイトへ送信
		- 金銭の送金や設定変更、退会といったことが起きる
	- 対策
		- ログインした利用者からのリクエストが利用者の意図したリクエストであるか識別する仕組みを持たせる
			- 処理を実行する直前で再度パスワードの入力を求める

### TypeScript
- 静的型付け言語、JavaScriptの上位互換
- any
	- 型定義を無視する
	- 初期化した値の型とは違う型の値を代入できる
- リテラルの場合は型定義しなくても型がわかるので省略可能
- 関数の型定義
```
const add = (a: number, b: number): number => {
  return a + b;
}

// returnしない場合は返り値の型を省略
```
- オブジェクトの型定義
```
// {method: () => void}
// methodはこのように型定義
```
- 型エイリアス
	- パスカルケースで記述
	- 型宣言を別ファイルに切り出すことができる
```
export type TodoItem = {
  id: string;
  name: string;
  isDone: boolean;
  isEdit: boolean;
};
```
- ユニオン型(OR)
	- 複数の型のうちどれか
	- `let value: string | number;`
- リテラル型
	- 特定の値だけを許可する型
	- `type Status = "loading" | "success" | "error";`
- インターセクション型(AND)
	- 複数の型を結合したい時
	- `let product1: Base & Prodct`
- オプショナルプロパティ
	- ?はundefinedは許可
	- nullはNG
	- そもそも?をつける場合、name: string | undefinedと同じだから。
	- つまり、nullは許容してないのでNG
- 型アサーション
	- 型推論できない時に型推論を上書きできる
	- 代入する値 as 型
		- `const element = document.getElementById('email')　as HTMLInputElement;`
- ジェネリクス
	- 抽象的な型引数
	- 実際に利用するまで型が確定しないような時に使う
	- ジェネリクスを使わないと、引数と返り値のあらゆる組み合わせを網羅しないといけない
		- 例えば、引数に入れた値がそのまま返るパターン
		- 実行時に引数として型を渡して対応する
	- `const remainValue = <T>(val: T): T => {...}`	
	- `remainValue<string>`などと利用する
- keyof
```
type OneDayMeals = {
  morning: string;
  lunch: string;
  dinner: string;
};

// (key: "morning" | "lunch" | "dinner")とも書けるが
// (key: keyof OneDayMeals)と省略して書ける
```
## 次やること
- ハンズオンで学ぶTypeScript

## 感じたこと
- 公式doc見て適宜オプションをつけたり応用できたらいいなーと思った


## 学習時間

| today | total |
| ----- | ----- |
| 7h    | 1189h |

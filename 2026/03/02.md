## 取り組んだ課題一覧
- TypeScript
	- ハンズオンで学ぶTypeScript
## わかったこと
- コンストラクタの引数にアクセス修飾子をつけると自動で初期化処理までする(Parameter Properties)
	- this.name = nameと記述するのが不要になる
- getter, setterはgetキーワード、setキーワードをつけたプロパティと同名のメソッドを作る
	- そうした場合、名前がぶつかるのでフィールド名を_nameのようにアンスコをつける
- readonly演算子
	- 参照専用のフィールドになる
- namespace
	- ディレクトリを切り分ければ、同名のファイルも扱えるという感じでディレクトリに当たるのがnamespace
	- クラス名の衝突など防ぐ
- 実装なしのメソッド定義をシグネチャー
- 抽象クラスはabstractキーワードをつけたクラス
	- 抽象メソッドは抽象クラスに書かれなければならない
	- 抽象クラスはnewできない
	- 抽象メソッドはオーバーライドして利用する
		- 実際はエラーが表示されるので、抽象メソッドのオーバーライド漏れは起きない
- TypeScriptは複数クラスの継承が許されていない、単一継承
- 複数インターフェースは多重継承のようなことができる
- 型の互換性
	- any型にnumber, string型を代入できる
	- string型に文字列リテラル、number型に数値リテラルを代入できる
	- Person型のpersonにDog型の値を代入できるかどうかは、型の構造で判定
	- Golangも同じ
	- >構造的型付け(structural typing)は、型の名前ではなく、その「構造」に着目して型の区別や互換性を判定するアプローチです。
- ジェネリクス
	- 型の安全性とコードの共通化を両立
- 型アサーション
	- 型推論を上書きする
	- >型アサーションはコンパイラに「私を信じて！私のほうが型に詳しいから」と伝えるようなものです。
	- 右辺で型を宣言して、早めに型を伝える、通常は変数に対してコロンで型注釈している
	- asを使う方法
- const アサーション
	- オブジェクトにas constをつけると、そのプロパティがreadonlyになる
- nullable types
	- string型など通常の型はnullを含まないので
	- string型のnameに対して、`name = null`とするとエラーになる
		- tsconfigがstrict=trueになるとエラーになる
- インデックスシグネチャ
	- 将来追加されるプロパティの型を制限できる
- utility types
	- `Partial<T>`
	- 全てのプロパティがoptionalになる型
	- `Required<T>`
	- 全てのプロパティが必須になる型
	- `Readonly<T>`
	- 全てのプロパティを読み取り専用にする
	- `Record<K, T>`
	- プロパティのキーがK、値の型がTであるようなオブジェクトの型を作る
		- これがないと同じような型を何度も書く必要がある
- conditional types
	- 3項演算子によって動的な型を定義できる
- Mapped Type
	- in keyofで型のキーを1つずつ取り出して、カスタマイズできる。コンパイル時の構文
	- Partialも同様の仕組みで作られている
- >`Exclude<T, U>`は、ユニオン型`T`から`U`で指定した型を取り除いたユニオン型を返すユーティリティ型
	- Extract<T, U>でTのうち、Uを抽出ができる
- NonNullable\<T>
	- ユニオン型Tからnull, undefinedを除いた型を取り出す
- Excludeの定義
	- `type Exclude<T, U> = T extends U ? never : T;`
	- TがUを持っているかどうか
		- trueならneverで除外
		- falseならTを残す
```
type Exclude<T, U> = T extends U ? never : T;

type Result = Exclude<string | number | boolean, number>;

/* 内部では分配されて以下のようになる
Exclude<string, number>
| Exclude<number, number>
| Exclude<boolean, number>
*/
```
- Tにそのままstring | number | booleanが入るのではなく、一つずつ分配される
	- これをdistributive conditional types
- Pick<T, Keys>
	- 型TからKeyに指定したキーだけを含むオブジェクトの型を返す
- Omit<T, Keys>
	- PickのExclude版
- ReturnType\<T>
	- 関数型Tの戻り値を取得するutility型
	- typeofと併用して、実際の関数の戻り値の型を取得する
	- >typeofは変数から型を取得する演算子です。JavaScriptのtypeofとは異なるので注意してください。
- SWC
	- speedy web compiler
	- 通常はTypeScriptコンパイラ
	- Rust製でJavaScriptへのトランスパイルが高速
	- 型チェック機能はないが、IDEで内部的にtsc --noEmitされている
		- --noEmitで出力しない設定
- Parameters\<T>	
	- 関数の引数をtuple型で取り出す
- ConstructorParameters\<T>
	- コンストラクタの引数をtuple型で取り出す
- Reactの関数コンポーネントの型
	- FunctionComponentまたはFCで関数コンポーネントの型を定義、引数の型
		- childrenが暗黙的にpropsの方として追加される。
		- すると、childrenがあった場合のバグに気付けない
		- なので、今はpropsに型を渡すのが主流
	- 戻り値の方はJSXElementで型推論してるので不要
- lockの意味
	- >`package-lock.json`に関しては、`npm install`した際に、インストールされた各ライブラリのバージョンと、そのライブラリを使用するのにインストールしたライブラリのバージョンが自動で記述されます。
-  グローバルCSSは最小限にする
	- `import "./index.css";`など。
	- リセットCSSや基本的なスタイルを当てるに留める。
- Fragment
	- JSXElementを返すとき1つのタグしかreturnできない
	- しかし、divタグで囲むとdivのネストが深くなりがち
	- Fragment(<>\</>)を使うと、実際のHTML上はタグを生成せず、tsx上で、一つのタグに収めることができる

## 次やること
- ハンズオンで学ぶTypeScript

## 感じたこと
- typeofやkeyofが同名の演算子でややこしい

## 学習時間

| today | total |
| ----- | ----- |
| 6h    | 1205h |
